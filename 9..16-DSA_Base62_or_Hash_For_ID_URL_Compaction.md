# Base62 encoding

## Table of Contents

- [Base62 encoding](#base62-encoding)
  - [Why use it in System Design?](#why-use-it-in-system-design)
  - [Comparison with a hashing approach](#comparison-with-a-hashing-approach)
  - [Collision free encoding by using a sequential counter](#collision-free-encoding-by-using-a-sequential-counter)
    - [Bijective functions](#bijective-functions)
    - [Base62 compared to a Hash function](#base62-compared-to-a-hash-function)
    - [The only case where we see collisions in Base62 encoding](#the-only-case-where-we-see-collisions-in-base62-encoding)

Base62 is a method to make numbers / IDs **shorter** and **readable** by using more characters to represent them. Instead of just using 10 digits (`0-9`), we use 62 characters:
- `0-9` (10 digits)
- `a-z` (26 lowercase)
- `A-Z` (26 uppercase)

```
Input ID: 11157
           |
           v
   +-----------------+
   | DIVIDE BY 62    |
   +-----------------+
           |
   +-------+-------+
   |               |
Quotient       Remainder
  179             57  -----> [ Map to 'V' ]
   |               
   v               
 (Repeat)          
   |               
179 / 62           
   |               
   +-------+-------+
   |               |
Quotient       Remainder
   2              55  -----> [ Map to 'T' ]
   |
   v
 (Repeat)
   |
 2 / 62
   |
   +-------+-------+
   |               |
Quotient       Remainder
   0               2  -----> [ Map to '2' ]
   |
 (STOP)
 
 Result (Reversed): "2TV"
```

## Why use it in System Design?

- **Compactness**: It **shrinks long** database **IDs** into short strings. A 10-digit ID (e.g., `1,000,000,000`) becomes just 6 characters in Base62. This is *critical for URL Shorteners* (like bit.ly) or *user-friendly IDs* (like YouTube video IDs)
- **URL Safe**: Unlike Base64, which uses *special characters* like `+` and `/` that can break URLs, Base62 uses only alphanumeric characters that work perfectly in any browser

## Comparison with a hashing approach

**Hashing**: Hashing is like taking a digital "fingerprint" of data. It turns any amount of input (a password, a file, a URL) into a *random-looking string of **fixed** length*

Key Rule: It is ***one-way***. You cannot turn the fingerprint back into the original person

Ex: Instead of Base62 encoding, Hash the ID/URL and take the first x digits! Similar result as that of encoding! However, hashing will _have collisions too when the available space is smaller than the data set_!

Use cases:
- Data Integrity: To check if a file was corrupted during download (Checksums)
- Sharding/Load Balancing: To evenly distribute data across servers (Consistent Hashing uses the hash of an ID to pick a server)
- Security: Storing passwords so that even if the DB is stolen, the actual passwords aren't visible

Hashing tools:
|Algo  |Pros            |Cons |Best Use      |
|------|----------------|-----|--------------|
|MD5   |Extremely fast, short output.|Broken. Collisions are easy to find.|Non-security tasks (e.g., checksums for internal cache keys).|
|SHA-256|Highly secure, industry standard.|Slower to calculate than MD5.|Passwords, TLS Certificates, Blockchain.|

## Collision free encoding by using a sequential counter

Use a **sequential counter** and encode the ID/URL
- Instead of a random number generator, increment a counter (that *grows linearly* from maybe `0` to `1Bn`)
- Encode this number into `Base62`, thereby compacting the number of characters/digits
- **Pros**: ***No collision*** since it is a *sequentially growing number*!
- **Cons**: ***Predictable*** since the number grows sequentially. This is a security risk (Others can get all the short URLs i.e guess it)
	- ***Solution***: Use "**Bijective functions**" like **SQIDS** / **hashids**
		- Bijective functions guarantee 1:1 mapping but are still predictable (**SECURITY ISSUE** - ANYONE CAN GUESS THE NEXT SET OF IDs/URLs)
		- Sqids guarantee unpredictability by ***shuffling the mapping***

### Bijective functions

The Simple Concept: "The Perfect Pair". A Bijective Function is a mapping where every element in `Set A` pairs up perfectly with exactly one element in `Set B`. No one is left out, and no one shares a partner

**SQIDS / Hashids**

- An open source library / tool
- It is Bijective (Reversible) because it is just math: it maps one number to one string using a specific rule
- It is "Unpredictable" (Obfuscated) because it changes the rule (shuffles the alphabet) for every single ID it processes

```
       STANDARD BASE62 (Predictable)
       Alphabet: [ 0, 1, 2, 3 ... ] (Fixed)
       
       ID: 1  ---->  "1"
       ID: 2  ---->  "2"  (Obvious Pattern)

       =======================================

       SQIDS (Obfuscated)
       
       ID: 1
         |--> (Step A) Calc Lottery Char: "X"
         |--> (Step B) Shuffle Alphabet using "X": [ 9, b, A, ... ]
         |--> (Step C) Encode "1" using New Alphabet -> "9"
         |--> Result: "X9"

       ID: 2
         |--> (Step A) Calc Lottery Char: "b"
         |--> (Step B) Shuffle Alphabet using "b": [ Q, 5, z, ... ]
         |--> (Step C) Encode "2" using New Alphabet -> "z"
         |--> Result: "bz" (Completely different!)
```

### Base62 compared to a Hash function

|Feature|Base62 Encoding |Hashing (MD5/SHA256)          |
|-------|----------------|------------------------------|
|Function Type|Bijective (1-to-1)|Surjective (Many-to-1)*       |
|Collisions|Impossible (by definition)|Possible (Collision handling required)|
|Reversibility|Yes (You can decode the string to get the ID)|No (One-way functions)        |
|Output Length|Variable (Grows as ID grows)|Fixed (e.g., 128-bit or 160-bit)|
|Prediction|Easy (if ID=1 is a, ID=2 is b)|Hard (Avalanche effect)       |

### The only case where we see collisions in Base62 encoding

If you **randomize the ID generator** (ex: random number generator for creating short URLs) then you have collisions -- This has nothing to do with BASE62 (NO COLLISION) encoding -- But, it has to do with the fact that random number generator WILL RESULT IN SOME COLLISIONs even for a pretty large dataset!
