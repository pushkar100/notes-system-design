# Quick Revision: CAP Theorem and PACELC

The CAP theorem is the *fundamental law of distributed systems*. It proves that in a distributed network, you cannot have it all.

## Table of Contents

- [Quick Revision: CAP Theorem and PACELC](#quick-revision-cap-theorem-and-pacelc)
  - [The Core Concept](#the-core-concept)
  - [The "Gotcha": It's not "Pick any 2"](#the-gotcha-its-not-pick-any-2)
  - [The Trade-Off Scenario (Visualized)](#the-trade-off-scenario-visualized)
  - [Table to understand CAP](#table-to-understand-cap)
  - [Advanced Concept: PACELC](#advanced-concept-pacelc)
  - [Where to use in System Design?](#where-to-use-in-system-design)
  - [Popular tools and the CAP theorem](#popular-tools-and-the-cap-theorem)
  - [PACELC deep dive](#pacelc-deep-dive)

## The Core Concept

CAP states that a distributed data store can ***only provide two of the following three guarantees simultaneously***:
1. **Consistency (`C`)**: (Specifically **Strong Consistency**). ***Every read receives the most recent write or an error***. ***All nodes see the same data at the same time***
2. **Availability (`A`)**: ***Every request receives a (*non-error*) response, without the guarantee that it contains the most recent write***
3. **Partition Tolerance (`P`)**: ***The system continues to operate despite an arbitrary number of messages being dropped or delayed by the network between nodes***

## The "Gotcha": It's not "Pick any 2"

In the real world (System Design), **Partition Tolerance (P) is mandatory**

Networks fail. Cables get cut. Switches crash. You cannot choose to have a system that isn't Partition Tolerant, because that implies your system shuts down the moment a network packet is lost.

**The Real Choice**: When a network failure (Partition) occurs, you must choose between:
1. **CP (Consistency + Partition Tolerance)**: "I'd rather return an Error than show you old data"
2. **AP (Availability + Partition Tolerance)**: "I'd rather show you old data than return an Error"

## The Trade-Off Scenario (Visualized)

Imagine two database nodes, Node 1 and Node 2, *trying to stay in sync*. A network failure cuts the connection between them

Scenario: The Partition Hits
- User writes `Balance = $100 `to Node 1
- Node 1 cannot tell Node 2 because the line is cut
```
       [ User ]
          |
    (Write: $100)
          v
      [ Node 1 ]  <---// NETWORK CUT //--->  [ Node 2 ]
     (State: $100)                          (State: $0)
```
- Now, a second User asks Node 2: "What is the balance?"

**Choice A: The CP System (Banking)**
- Logic: Node 2 knows it cannot talk to Node 1. It suspects its data might be stale!
- Action: Node 2 returns an Error or Time out
- Result: **System is Consistent (no wrong data shown), but Unavailable (User got an error)**

**Choice B: The AP System (Social Media)**
- Logic: Node 2 cannot talk to Node 1. It decides keeping the user happy is more important
- Action: Node 2 returns $0
- Result: **System is Available (User got a response), but Inconsistent (User saw $0, but it's actually $100)**

## Table to understand CAP

|Feature|CP (Consistency)|AP (Availability)|
|-------|----------------|-----------------|
|Philosophy|"Correctness > Uptime"|"Uptime > Correctness"|
|Behavior during Partition|Blocks writes/reads to minority nodes. Returns Errors.|Accepts writes/reads on all nodes. Resolves conflicts later.|
|Data Sync|Synchronous (mostly).|Asynchronous (Eventual Consistency).|
|Conflict Resolution|None needed (Single source of truth).|Complex (Vector Clocks, Last-Write-Wins).|
|Examples|**HBase, MongoDB, Redis (default)**|**Cassandra, DynamoDB, Riak**|

## Advanced Concept: PACELC

The CAP theorem *only describes what happens during a failure*. ***But what about when the system is running normally (99% of the time)?***

PACELC Theorem *expands on* CAP:
- If Partition (P): Choose A or C.
- **Else (E) (Normal operation): Choose L (Latency) or C (Consistency).**

Example: DynamoDB
- During Partition: It chooses *Availability* (AP)
- Normal Operation: It sacrifices *Consistency for low Latency.* (It returns data fast from one node, rather than waiting for all nodes to agree).

## Where to use in System Design?

1. "Design an ATM / Payment System"
	- Choice: CP (**Consistency**)
	- Defense: "In banking, we cannot allow a double spend. If the network is down, it is better to decline the transaction (Availability hit) than to let a user withdraw money they don't have (Consistency failure)."
- Tech: Relational DBs (Postgres), CP-tuned NoSQL (HBase)

2. "Design a Shopping Cart"
	- Choice: AP (**Availability**)
	- Defense: "If Amazon's network is glitchy, we should still let users add items to the cart. We can't block a sale just to sync data. If they add an item on mobile and it doesn't show up on desktop immediately, that's acceptable. We will reconcile the cart items later."
	- Tech: DynamoDB, Cassandra

3. "Design Facebook Likes"
	- Choice: AP (**Availability**)
	- Defense: "It doesn't matter if a post has 1,000 or 1,001 likes. It is critical that the 'Like' button always works (Availability). We accept eventual consistency."

## Popular tools and the CAP theorem

```
      (Consistency + Availability)
             CA *Theoretical*
           (RDBMS Single Node)
              /      \
             /        \
            /          \
           /            \
    (CP)  <--------------->  (AP)
Consistency              Availability
+ Partition Tol.         + Partition Tol.
   [CP Tools]              [AP Tools]
 • MongoDB                • Cassandra
 • HBase                  • DynamoDB (Default)
 • Redis                  • Couchbase
 • RDBMS (Cluster)        • DNS
```

|Tool  |Category        |CAP Position|Why? (The Interview Answer)                                                                                                                                               |
|------|----------------|------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|MySQL / Postgres|RDBMS           |CP (Cluster)|ACID compliant. In a cluster, if the Primary node loses connection to the Replica, the system usually stops writes (or risks data loss) to preserve Consistency.          |
|MongoDB|NoSQL (Document)|CP          |Single Leader. Writes only go to the Primary. If the Primary dies, the system is Unavailable for writes (for a few seconds) until a new leader is elected.                |
|HBase / BigTable|NoSQL (Wide Col)|CP          |Single Leader. Data is strictly partitioned. If a RegionServer dies, that specific data range is inaccessible until recovery.                                             |
|Cassandra|NoSQL (Wide Col)|AP          |Masterless (Peer-to-Peer). You can write to any node. If one node is down, others accept the write. Result: High Availability, but data might be inconsistent temporarily.|
|DynamoDB|NoSQL (Key-Value)|AP (Default)|Leaderless-style logic. Returns data fast from any replica (Eventual Consistency). Note: Can be tuned to CP with "ConsistentRead".         |

## PACELC deep dive

The CAP theorem is criticized because network partitions (failures) are rare. PACELC acknowledges that systems spend 95% of their time in "**Normal Operation**," and you still have to make a tough choice during that time.

Here is the breakdown of the **"Else" (E) component**:

**The Core Tension: Speed vs. Truth**

When the network is *working perfectly* (No Partition), ***you still cannot have everything***. You must choose between Latency (Speed) and Consistency (Accuracy)

- **Choosing Latency (L)**: "I will return the first copy of the data I find immediately."
	- Result: *Super fast response, but you might read data that is a few milliseconds old (Replication Lag)*.

- **Choosing Consistency (C)**: "I will wait until I check with the Leader/Quorum to ensure this data is the latest version."
	- Result: *100% accurate data, but the user waits longer (High Latency) because of the extra cross-talk between servers*

**The DynamoDB Example (Real World)**

DynamoDB follows PACELC perfectly *because it allows you to make this choice per request*

Scenario: Normal Operation (*Else*)
- *Default (Eventual Consistency)*: You make a standard `GetItem` call
	- Choice: L (Latency)
	- Behavior: DynamoDB checks the node closest to you. If that node says "Item count: 5", it returns "5" instantly. It does not waste time checking if the Leader actually updated it to "6" a millisecond ago
	- Benefit: Extremely low latency (single-digit ms)
- *Option (Strong Consistency)*: You set `ConsistentRead: true`
	- Choice: C (Consistency)
	- Behavior: DynamoDB ignores the closest node. It forces a network call to the Leader node to get the absolute truth
	- Cost: The read takes longer (Latency increases) and costs twice as much money (literally, in AWS pricing)

```
      Is there a Partition (Failure)?
               /          \
             YES           NO (Normal Operation)
             /                \
        [ CAP Choice ]       [ PACELC "Else" Choice ]
        /          \           /              \
       A     OR     C         L        OR      C
  (Keep Up)     (Error)    (Fast)           ( accurate )
                            ^                  ^
                            |                  |
                   DynamoDB Default      DynamoDB w/
                                      "ConsistentRead: True"
```
