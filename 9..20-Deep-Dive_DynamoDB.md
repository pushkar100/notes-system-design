# Deep Dive: DynamoDB

## Table of Contents

- [Deep Dive: DynamoDB](#deep-dive-dynamodb)
  - [Table of Contents](#table-of-contents)
  - [What is DynamoDB?](#what-is-dynamodb)
  - [Data model in DynamoDB](#data-model-in-dynamodb)
  - [Indexing - How to query by other fields](#indexing-how-to-query-by-other-fields)
  - [Architecture & Consistency](#architecture-consistency)
  - [When to use it?](#when-to-use-it)
    - [Avoid DynamoDB and use SQL instead:](#avoid-dynamodb-and-use-sql-instead)
  - [Example system design diagrams](#example-system-design-diagrams)
  - [DynamoDB vs Cassandra](#dynamodb-vs-cassandra)
    - [Cassandra does not need a cache but DynamoDB might - Why?](#cassandra-does-not-need-a-cache-but-dynamodb-might-why)
  - [DynamoDB vs Redis](#dynamodb-vs-redis)
  - [DynamoDB vs SQL](#dynamodb-vs-sql)

## What is DynamoDB?

DynamoDB is a ***fully managed, key-value NoSQL database provided by AWS***. It is designed for *high scalability* and *low latency*

- **Fully Managed**: AWS handles hardware provisioning, patching, and scaling
- **Schema-less**: Unlike SQL, you do not need to define all columns upfront. Items in the same table can have different attributes.
- **Key-Value**: It does not use the traditional relational model; instead, it optimizes for looking up data via unique keys

## Data model in DynamoDB

DynamoDB organizes data into ***Tables, Items (rows), and Attributes (columns)***. The most critical decision in your design is defining the **Primary Key,** which comes in two flavors:

- **Partition Key (PK)**: A unique identifier (e.g., UserID, ChatID).
	- Function: DynamoDB hashes this key to determine which physical partition (server) stores the data.
	- Goal: You want a PK that *evenly distributes traffic across partitions to avoid "hot keys"*
- **Sort Key (SK)**: An *optional* second part of the key (e.g.,`Timestamp`, `MessageID`)
	- Function: It sorts items within a single partition
	- Goal: *Enables efficient range queries* (e.g., "Give me all messages in this chat between 5 PM and 6 PM")

Example for a Chat Application:
- Partition Key: `ChatID` (groups all messages for a specific chat together)
- Sort Key: `MessageID` (monotonically increasing ID to sort messages by time)

```
+-------------------------------------------------------------------+
|                           DynamoDB Table                          |
+-------------------------------------------------------------------+
|                                                                   |
|  +-------------------------------------------------------------+  |
|  | Item (Row)                                                  |  |
|  +-------------------------------------------------------------+  |
|  | Primary Key (PK) | Sort Key (SK) | Attribute 1 | Attribute 2 |  |
|  | (e.g., ChatID)   | (e.g., MsgID) | (e.g., Text)| (e.g., User)|  |
|  +==================+===============+=============+=============+  | <-- Attributes
|  | "chat#123"       | "001"         | "Hello!"    | "user_a"    |  |
|  +------------------+---------------+-------------+-------------+  |
|  | "chat#123"       | "002"         | "Hi there"  | "user_b"    |  |
|  +------------------+---------------+-------------+-------------+  |
|  | "chat#456"       | "001"         | "New chat"  | "user_c"    |  |
|  +------------------+---------------+-------------+-------------+  |
|                                                                   |
+-------------------------------------------------------------------+
```

## Indexing - How to query by other fields

If you need to query data by an attribute that isn't your Primary Key, you must use ***Secondary Indexes***

|Feature|Global Secondary Index (GSI)|Local Secondary Index (LSI)   |
|-------|----------------------------|------------------------------|
|Definition|A copy of the table with a different Partition Key.|Same Partition Key, but a different Sort Key.|
|Physical Storage|Stored in its own separate partition with its own throughput settings.|Stored alongside the main table data.|
|Use Case|querying across partitions (e.g., "Find all messages sent by User X across all chats") |Alternate sorting within a partition (e.g., "Find messages in this chat with the most attachments") |
|Constraint|Eventual consistency only.  |Strong consistency supported; limited to 10GB per partition.|

```
 [ BASE TABLE ]                               [ GSI: UserID-Index ]
 PK: ChatID, SK: MsgID                        PK: UserID (New PK!)

+------------+-------+--------+          +----------+------------+-------+
| ChatID(PK) | MsgID | UserID |          | UserID(PK)| ChatID(SK) | MsgID |
+============+=======+========+          +===========+============+=======+
| "chat#123" | "001" | "u_a"  | --copy-->| "u_a"     | "chat#123" | "001" |
+------------+-------+--------+          +----------+------------+-------+
| "chat#123" | "002" | "u_b"  | --copy-->| "u_b"     | "chat#123" | "002" |
+------------+-------+--------+          +----------+------------+-------+
| "chat#456" | "001" | "u_a"  | --copy-->| "u_a"     | "chat#456" | "001" |
+------------+-------+--------+          +----------+------------+-------+
                                         (Query: Find all messages by "u_a")
```

```
 [ Single Physical Partition for ChatID="chat#123" ]

+-----------------------------------+   +-----------------------------------+
|       Base Table View             |   |        LSI View (by UserID)       |
|     (Sorted by MsgID)             |   |       (Sorted by UserID)          |
+===================================+   +===================================+
| PK: "chat#123", SK: "001", "u_a"  |   | PK: "chat#123", SK: "u_a", "001"  |
+-----------------------------------+   +-----------------------------------+
| PK: "chat#123", SK: "002", "u_b"  |   | PK: "chat#123", SK: "u_b", "002"  |
+-----------------------------------+   +-----------------------------------+
| PK: "chat#123", SK: "003", "u_a"  |   | PK: "chat#123", SK: "u_b", "004"  |
+-----------------------------------+   +-----------------------------------+
```

## Architecture & Consistency

***Scaling via Consistent Hashing***: DynamoDB places data on a "ring" of physical nodes based on the hash of the Partition Key. If a node is added or removed, only its immediate neighbors are affected

```
          Hash Ring
      (Key Space: 0-100)

          Node A (0-25)
            /   \
           /     \
Node D (76-100)   Node B (26-50)
           \     /
            \   /
          Node C (51-75)

Incoming Write -> Hash("chat#123") = 30  ->  Lands on Node B
Incoming Write -> Hash("chat#999") = 85  ->  Lands on Node D
```

- **Replication**: It uses a **Leader-Follower** model
	- Writes go to a single Leader node and are asynchronously replicated to followers in different Availability Zones (AZs)

- **Consistency Levels**:
	- **Eventual Consistency (Default)**: Fast and cheaper. Reads might come from a replica that is slightly out of sync (milliseconds lag)
	- **Strong Consistency**: You can ***opt into*** this. Reads are routed to the Leader to guarantee the latest data, but it ***costs more and has higher latency***

```
                  [ Application ]
                           |
        +------------------+------------------+
        | Write (Always)   | Read (Strong)    | Read (Eventual)
        v                  v                  v
+---------------+   +---------------+   +---------------+
| Leader Node   |-->| Follower Node |   | Follower Node |
| (AZ 1)        |   | (AZ 2)        |   | (AZ 3)        |
+---------------+   +---------------+   +---------------+
        | (Async Replication)
        +------------------------------------->


Strong Consistency: Reads go to the Leader, which always has the latest data

Eventual Consistency: Reads can go to any Follower, 
which might have a slight replication lag
```

## When to use it?

Use DynamoDB if:
1. You need ***massive scale*** (millions of requests/sec)
2. Your ***access patterns are simple*** (key-value lookups)
3. You are designing systems like Url Shorteners, Shopping Carts, or Key-Value Caches

### Avoid DynamoDB and use SQL instead:

4. You have *complex query patterns requiring many joins*
5. You need *complex analytics* or *aggregations*
6. You require *highly complex transactions involving many tables*

## Example system design diagrams

```
       +--------+
       | Client |
       +----+---+
            |
            v
    +-------+--------+
    |  API Gateway   |  <--- (1) REST / WebSocket Entry
    +-------+--------+
            |
            v
    +-------+--------+
    |   Compute      |  <--- (2) Stateless Logic
    | (Lambda / EC2) |       (AWS SDK)
    +-------+--------+
            |
            | (3) PutItem / GetItem
            v
    +=======+========+
    |    DynamoDB    |  <--- (4) Primary DB
    |     Table      |       (Key-Value Access)
    +=======+========+
            |
            | (5) DynamoDB Stream (CDC)
            v
    +-------+--------+
    | Async Worker   |  <--- (6) Decoupled Processing
    |    (Lambda)    |       (e.g., Send Welcome Email)
    +----------------+
 ```

*DynamoDB horizontally scaled / distributed example*:
```
       [   REGION A (US-EAST)   ]                  [   REGION B (EU-WEST)   ]
       +------------------------+                  +------------------------+
       |        Client          |                  |        Client          |
       +-----------+------------+                  +-----------+------------+
                   |                                           |
                   v                                           v
           +-------+-------+                           +-------+-------+
           |  API Gateway  |                           |  API Gateway  |
           +-------+-------+                           +-------+-------+
                   |                                           |
                   v                                           v
           +-------+-------+                           +-------+-------+
           |    Service    |                           |    Service    |
           |   (Lambda)    |                           |   (Lambda)    |
           +-------+-------+                           +-------+-------+
                   |                                           |
        (1) Read   | (2) Read Miss                  (1) Read   | (2) Read Miss
            Hit    |     or Write                       Hit    |     or Write
                   v                                           v
           +-------+-------+                           +-------+-------+
           |      DAX      |                           |      DAX      |
           |    (Cache)    |                           |    (Cache)    |
           +-------+-------+                           +-------+-------+
                   |                                           |
                   v                                           v
        +==========+==========+                     +==========+==========+
        |   DynamoDB Table    |   (3) < 1 sec       |   DynamoDB Table    |
        |     (Region A)      | <-----------------> |     (Region B)      |
        +=====================+     Replication     +=====================+
             ^                                           ^
             | (4) Global Tables                         |
             |     (Active-Active)                       |
             +-------------------------------------------+
```

## DynamoDB vs Cassandra

When to use which?
- Use Cassandra if:
	- You are ingesting massive amounts of write-heavy data (e.g., sensor logs, IoT data streams, chat history)
	- You need to run on-premise or across multiple cloud providers
	- You have a dedicated DevOps team to manage the cluster (Cassandra is notoriously hard to maintain).

Use DynamoDB if:
- You want similar scalability to Cassandra but without the maintenance burden.
- You are okay with the AWS vendor lock-in

### Cassandra does not need a cache but DynamoDB might - Why?

The difference lies in their **internal storage engines** and **I/O paths**

1. Cassandra (**LSM Tree Architecture**)
	- Write Path: Writes go directly into a ***Memtable*** (RAM) and a ***Commit Log*** (Disk).
	- Read Path: Reads check the Memtable first
	- Result: ***Recently written data is already sitting in memory***. Reading it back is a microsecond-latency memory operation. ***The database is the cache for hot data***

2. DynamoDB (B-Tree Architecture)
	- Write Path: Writes are ***persisted to SSDs across multiple Availability Zones for durability***
	- Read Path: Every read request must traverse the network to a storage node and often perform a disk seek on the SSD
	- Result: This incurs network and disk I/O latency (~5-10ms). ***To achieve microsecond latency or avoid paying for repeated disk reads, you must add an explicit caching layer (DAX or Redis)***

Summary: Cassandra writes to RAM (fast reads built-in); DynamoDB writes to Disk (requires external cache for RAM speed)

## DynamoDB vs Redis

Use Redis if:
- You need extreme speed (caching, real-time analytics)
- Data loss is acceptable (e.g., user sessions, caching API responses)
- You need specialized structures like Leaderboards (Sorted Sets) or Pub/Sub

Use DynamoDB if:
- This is your **System of Record (you cannot lose data)**
- You need a **persistent key-value store** (e.g., User Profiles)

## DynamoDB vs SQL

When to use PostgreSQL/MySQL:
- You are building an early-stage product and don't know the query patterns yet.
- You need strong ACID compliance for complex business logic (e.g., banking ledgers, inventory management).
- Your data has complex relationships (e.g., A social network graph where you need to hop between many tables).

Use DynamoDB if:
- You have massive scale (millions of users) and need predictable, low-latency performance (single-digit ms)
- Your data is simple and disconnected (e.g., a Shopping Cart, User Session data)
- You are fully in the AWS ecosystem and want a "serverless" solution (no maintenance)
