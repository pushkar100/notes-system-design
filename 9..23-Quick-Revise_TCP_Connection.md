# Quick Revision: TCP connecting pooling and its need

## Table of Contents

- [Quick Revision: TCP connecting pooling and its need](#quick-revision-tcp-connecting-pooling-and-its-need)
  - [What is TCP Connection Pooling?](#what-is-tcp-connection-pooling)
  - [Visual Comparison](#visual-comparison)
  - [Why is it Needed?](#why-is-it-needed)
  - [Where is it used?](#where-is-it-used)
  - [Tools that implement it](#tools-that-implement-it)
  - [Benefits and drawbacks](#benefits-and-drawbacks)
  - [Redis example](#redis-example)
- [1. Create the Pool ONCE (e.g., max 10 connections)](#1-create-the-pool-once-eg-max-10-connections)
- [2. Initialize the client using the pool](#2-initialize-the-client-using-the-pool)

## What is TCP Connection Pooling?

TCP Connection Pooling is the practice of ***keeping a set of established network connections open and reusable***, rather than opening and closing a new connection for every single request

- *Without Pooling*: You open a connection, send data, and close it immediately
- *With Pooling*: You open a connection once, send data, keep it open (idle), and reuse it for the next request

## Visual Comparison

*Scenario A*: Without Pooling (Inefficient) Every request requires a full setup and teardown
```
 [ Client ]                       [ Server ]
    |                                |
    | --(SYN)----------------------> | \
    | <-(SYN-ACK)------------------- |  | 3-Way Handshake
    | --(ACK)----------------------> | /  (Slow!)
    |                                |
    | --(Request: Get Data)--------> |
    | <-(Response: Here is Data)---- |
    |                                |
    | --(FIN: Close)---------------> |  <-- Connection Destroyed
    |                                |
    |   (New Request needed? Start over!)
```

*Scenario B*: With Pooling (Efficient) The handshake happens only once. Subsequent requests are fast
```
 [ Client ]                       [ Server ]
    |                                |
    | --(SYN / SYN-ACK / ACK)------> | (Handshake Once)
    |                                |
    | --(Request 1)----------------> |
    | <-(Response 1)---------------- |
    |                                |
    |    (Connection stays IDLE)     | <-- POOLED
    |                                |
    | --(Request 2)----------------> | (Immediate!)
    | <-(Response 2)---------------- |
```

## Why is it Needed?

1. **Latency (Speed)**: The TCP 3-way handshake takes time (network round trips). *If you use HTTPS (SSL/TLS), the handshake is even slower (up to 7 round trips)*. Pooling eliminates this delay for subsequent requests
2. **CPU Usage**: Creating a connection requires the Operating System (OS) to allocate *memory* and *file descriptors*. Doing this thousands of times per second consumes high CPU
3. **Port Exhaustion**: Every connection uses a local port. The OS has a limit (~65,000 ports). If you open/close too fast, you run out of ports because closed connections hang around in a `TIME_WAIT` state for a few minutes before they are truly freed

## Where is it used?

1. **Database Access**: Connecting to a database (like PostgreSQL or MySQL) is very heavy. Applications use pools to maintain ~10-50 open connections ready for queries
2. **Microservices Communication**: Service A calling Service B ***repeatedly*** via HTTP/REST or gRPC.
3. **Web Browsers**: Your browser keeps a connection open to a website (Keep-Alive) to download images/CSS without reconnecting for every file

## Tools that implement it

|Category             |Tool / Library                                                              |
|---------------------|----------------------------------------------------------------------------|
|Database (PostgreSQL)|**PgBouncer** (A standalone proxy that sits in front of the DB to manage pools).|
|Java (JDBC)          |**HikariCP** (The standard high-performance JDBC connection pool).              |
|Python               |**SQLAlchemy** (ORM with built-in pooling), Requests (via Session object).      |
|Web Servers          |**Nginx / HAProxy** (Keep connections open to backend servers).                 |
|Node.js              |**pg-pool** (For Postgres), generic HTTP agents.                                |


## Benefits and drawbacks

|Feature              |Benefits                                                                    |Drawbacks                                                                                                           |
|---------------------|----------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------|
|Performance          |**Faster Response Time**. Skips the handshake overhead.                         |**Memory Usage**. Idle connections sit in RAM even if no one is using them.                                             |
|Stability            |**Prevents Overload**. You can limit the pool size (e.g., "Max 50 connections") to protect the database from being flooded.|**Stale Connections**. If a firewall cuts a connection silently, the pool might try to use a "dead" connection and fail.|
|Resource Usage       |**Saves Ports**. Prevents the "Ephemermal Port Exhaustion" crash.               |**Complexity**. You must manage configuration (e.g., "Max Lifetime," "Idle Timeout") to prevent errors.                 |

## Redis example

If you create a new client instance inside every function call, you force a new TCP handshake every time.

```python
import redis

def process_request():
    # BAD: Opens a NEW connection (Handshake) every time this runs
    r = redis.Redis(host='localhost', port=6379) 
    r.set('foo', 'bar')
    # Connection closes (or hangs) when function ends
```

You create the ***pool globally (once)***. The client reuses these connections.
```python
import redis

# 1. Create the Pool ONCE (e.g., max 10 connections)
pool = redis.ConnectionPool(host='localhost', port=6379, max_connections=10)

# 2. Initialize the client using the pool
r = redis.Redis(connection_pool=pool)

def process_request():
    # GOOD: Reuses an existing connection from 'pool'
    # No TCP Handshake overhead!
    r.set('foo', 'bar')
```

```
    [ Python Application ]
             |
   (r.set)   |  (Request Connection)
             v
    +-----------------------+
    |    CONNECTION POOL    |
    |  [Conn 1]  [Conn 2]   | <--- Kept Open (Idle)
    |  [Conn 3]  [Conn 4]   |
    +-----------+-----------+
                |
       (Reuse Conn 1)
                |
                v
       [ Redis Server ]
```
