# Secondary Index

## Table of Contents

- [Secondary Index](#secondary-index)
  - [What is a Secondary Index?](#what-is-a-secondary-index)
  - [Why is a secondary index needed?](#why-is-a-secondary-index-needed)
  - [Pros and cons of secondary indexes](#pros-and-cons-of-secondary-indexes)
  - [Real-World Use Cases](#real-world-use-cases)
  - [When to Avoid secondary indexes?](#when-to-avoid-secondary-indexes)

##  What is a Secondary Index?

A secondary index is a ***separate data structure*** (usually a B-Tree or Hash) created on a database table to *allow fast data retrieval based on columns other than the **Primary Key***

Think of a library book:
1. **Primary Index**: The decimal number (Call Number) on the book spine. The physical books are arranged on the shelves in this order.
2. **Secondary Index**: The Author Catalog or Title Catalog on the computer. It doesn't hold the book itself; it holds a "pointer" (the Call Number) telling you where to find the book on the shelf.

In a database:
- **Primary Index**: Sorts the actual data on the disk (Clustered Index)
- **Secondary Index**: Stores the value of the specific column you indexed (e.g., Email) + a pointer to the Primary Key of that row

**Primary Key index**:
```
              [ Root Node: PK 100 - 500 ]
                     /           \
           _________/             \_________
          /                                 \
   [ Node: 100-200 ]                  [ Node: 300-500 ]
      /         \                        /         \
     /           \                      /           \
[ Leaf Page ]  [ Leaf Page ]      [ Leaf Page ]   [ Leaf Page ]
+-----------+  +-----------+      +-----------+   +-----------+
| PK: 101   |  | PK: 201   |      | PK: 301   |   | PK: 401   |
| Name: A   |  | Name: B   |      | Name: C   |   | Name: D   | <--- THE DATA IS HERE
| Age: 25   |  | Age: 30   |      | Age: 22   |   | Age: 40   |      (No extra hop needed)
+-----------+  +-----------+      +-----------+   +-----------+
```

**Secondary index (Non-clustered)**:
```
              [ Root Node: Emails A - Z ]
                     /           \
           _________/             \_________
          /                                 \
   [ Node: A - M ]                   [ Node: N - Z ]
      /         \                        /         \
     /           \                      /           \
[ Leaf Page ]  [ Leaf Page ]      [ Leaf Page ]   [ Leaf Page ]
+-------------++-------------+    +-------------+ +-------------+
| Email: A... || Email: B... |    | Email: C... | | Email: D... |
| PK: 101     || PK: 201     |    | PK: 301     | | PK: 401     | <--- ONLY THE POINTER
+-------------++-------------+    +-------------+ +-------------+      IS HERE
       |              |
       |              +----------------------------------+
       |                                                 |
       v  (The "Hop" / Lookups)                          v
(MUST Go to Primary Index to get "Age")      (MUST Go to Primary Index)
```

|Feature|Primary Key Structure (Clustered)|Secondary Index Structure (Non-Clustered)|
|-------|---------------------------------|-----------------------------------------|
|Tree Type|B+ Tree                          |B+ Tree                                  |
|Leaf Content|**Actual Data Rows (All Columns)**   |**Primary Key Values (Pointers)**            |
|Physical Order|The data on disk is sorted by this key.|The index is sorted, but the data on disk is not.|
|Lookup Cost|`O(log N)` (Direct access)         |`O(log N) + O(log N)` (Index search + Primary Key lookup)|

## Why is a secondary index needed?

Without a secondary index, databases can only efficiently search by the Primary Key. ***If you search by anything else, the database must perform a Full Table Scanâ€”meaning it looks at every single row in the table from start to finish to find matches***

Example: Imagine a Users table with 10 million rows
- Primary Key: `UserID (1, 2, 3...)`
- Query: `SELECT * FROM Users WHERE Email = 'john@example.com'`
- Without a Secondary Index: The database reads all 10 million rows to see which one has that email. *This is extremely slow*
- With a Secondary Index on Email: The database jumps directly to 'john@example.com' in the index, grabs the `UserID` (e.g., 450), and fetches just that one record

## Pros and cons of secondary indexes

|Pros (Advantages)|Cons (Disadvantages)|
|-----------------|--------------------|
|**Drastic Read Speedup**: Reduces lookup time from `O(N)` (scanning all rows) to **`O(logN)`** (using a *B-Tree*)|**Slower Writes**: Every time you `INSERT`, `UPDATE`, or `DELETE` a row, the database must update the table and every secondary index associated with it|
|**Efficient Sorting**: Helps with `ORDER BY` clauses. If you index `Created_At`, the database can retrieve rows in chronological order without sorting them in memory|**Increased Storage**: Indexes take up disk space. Heavily indexed tables can sometimes have indexes larger than the data itself|
|**Uniqueness**: Can enforce constraints (e.g., ensuring Email is unique across all users) |**Maintenance Overhead**: Indexes can become fragmented over time, requiring maintenance (re-indexing) to keep them efficient|

## Real-World Use Cases

**E-Commerce Filtering**:
- Scenario: A user searches for "Running Shoes" and filters by "Price: Low to High"
- Index: You need a secondary index on Category and Price to quickly find these items without scanning the entire product catalog

**Login Systems**:
- Scenario: A user logs in with their email
- Index: A unique secondary index on the Email column ensures fast lookups during authentication and prevents duplicate account registration

**Dashboard Analytics**:
- Scenario: A manager wants to see all "Pending" orders from "Last Month"
- Index: A composite secondary index on (Status, Date) allows the database to instantly grab only the relevant orders

## When to Avoid secondary indexes?

***You should not just index every column***. Avoid secondary indexes in these scenarios:

1. **Low Cardinality Columns**: If a column has very few unique values (e.g., `Gender = 'Male'/'Female'` or `Is_Active = true/false`), an *index is often useless*. The database might decide scanning the whole table is faster than jumping back and forth between the index and the data for 50% of the rows

2. **Write-Heavy Tables**: If a table (like an `Audit_Logs` or `Sensor_Data` table) receives *thousands of inserts per second but is rarely read*, adding indexes will *crush your write throughput*

4. **Small Tables**: If a table has fewer than ~1,000 rows, a full table scan is often faster than using an index due to the overhead of reading the index file first

5. **Long Text Columns**: Indexing a *massive Description* or `Blog_Content `column is *inefficient*. ***It consumes huge storage and makes updates slow*** (Use Full-Text Search engines like Elasticsearch for this instead)
